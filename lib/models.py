# flake8: noqa E501

# generated by datamodel-codegen:
#   filename:  workflow.json
#   timestamp: 2024-07-31T13:31:50+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List

from pydantic.v1 import AnyUrl, BaseModel, Extra, Field, constr


class Document(BaseModel):
    dsl: constr(
        regex=r'^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$'
    ) = Field(..., description='The version of the DSL used by the workflow.')
    namespace: constr(regex=r'^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$') = Field(
        ..., description="The workflow's namespace."
    )
    name: constr(regex=r'^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$') = Field(
        ..., description="The workflow's name."
    )
    version: constr(
        regex=r'^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$'
    ) = Field(..., description="The workflow's semantic version.")
    title: str | None = Field(None, description="The workflow's title.")
    summary: str | None = Field(None, description="The workflow's Markdown summary.")
    tags: Dict[str, Any] | None = Field(
        None, description="A key/value mapping of the workflow's tags, if any."
    )


class Event(BaseModel):
    class Config:
        extra = Extra.allow

    id: str | None = Field(None, description="The event's unique identifier")
    source: AnyUrl = Field(
        ..., description='Identifies the context in which an event happened'
    )
    type: str = Field(
        ...,
        description='This attribute contains a value describing the type of event related to the originating occurrence.',
    )
    time: datetime | None = None
    subject: str | None = None
    datacontenttype: str | None = Field(
        None,
        description='Content type of data value. This attribute enables data to carry any type of content, whereby format and encoding might differ from that of the chosen event format.',
    )
    dataschema: AnyUrl | None = None


class Emit(BaseModel):
    event: Event


class EmitTask(BaseModel):
    emit: Emit


class For(BaseModel):
    each: str | None = Field(
        'item',
        description='The name of the variable used to store the current item being enumerated.',
    )
    in_: str = Field(
        ...,
        alias='in',
        description='A runtime expression used to get the collection to enumerate.',
    )
    at: str | None = Field(
        'index',
        description='The name of the variable used to store the index of the current item being enumerated.',
    )


class Container(BaseModel):
    image: str = Field(..., description='The name of the container image to run.')
    command: str | None = Field(
        None, description='The command, if any, to execute on the container'
    )
    ports: Dict[str, Any] | None = Field(
        None, description="The container's port mappings, if any."
    )
    volumes: Dict[str, Any] | None = Field(
        None, description="The container's volume mappings, if any."
    )
    environment: Dict[str, Any] | None = Field(
        None,
        description='A key/value mapping of the environment variables, if any, to use when running the configured process.',
        title='ContainerEnvironment',
    )


class Run(BaseModel):
    container: Container


class Script(BaseModel):
    language: str = Field(..., description='The language of the script to run.')
    environment: Dict[str, Any] | None = Field(
        None,
        description='A key/value mapping of the environment variables, if any, to use when running the configured process.',
        title='ScriptEnvironment',
    )
    code: str


class Shell(BaseModel):
    command: str = Field(..., description='The shell command to run.')
    arguments: Dict[str, Any] | None = Field(
        None,
        description='A list of the arguments of the shell command to run.',
        title='ShellArguments',
    )
    environment: Dict[str, Any] | None = Field(
        None,
        description='A key/value mapping of the environment variables, if any, to use when running the configured process.',
        title='ShellEnvironment',
    )


class Run2(BaseModel):
    shell: Shell


class Workflow(BaseModel):
    namespace: str = Field(
        ..., description='The namespace the workflow to run belongs to.'
    )
    name: str = Field(..., description='The name of the workflow to run.')
    version: str = Field(
        ..., description='The version of the workflow to run. Defaults to latest'
    )
    input: Dict[str, Any] | None = Field(
        None,
        description="The data, if any, to pass as input to the workflow to execute. The value should be validated against the target workflow's input schema, if specified.",
        title='WorkflowInput',
    )


class Run3(BaseModel):
    workflow: Workflow = Field(..., title='RunWorkflowDescriptor')


class SetTask(BaseModel):
    set: Dict[str, Any] = Field(..., description='The data to set')


class FlowDirective1(Enum):
    continue_ = 'continue'
    exit = 'exit'
    end = 'end'


class FlowDirective(BaseModel):
    __root__: FlowDirective1 | str


class ReferenceableAuthenticationPolicy1(BaseModel):
    use: constr(min_length=1) = Field(
        ..., description='The name of the authentication policy to use'
    )


class SecretBasedAuthenticationPolicy(BaseModel):
    use: constr(min_length=1) = Field(
        ..., description='The name of the authentication policy to use'
    )


class Basic(BaseModel):
    username: str = Field(..., description='The username to use.')
    password: str = Field(..., description='The password to use.')


class AuthenticationPolicy1(BaseModel):
    basic: Basic | SecretBasedAuthenticationPolicy


class Bearer(BaseModel):
    token: str = Field(..., description='The bearer token to use.')


class AuthenticationPolicy2(BaseModel):
    bearer: Bearer | SecretBasedAuthenticationPolicy


class Client(BaseModel):
    id: str = Field(..., description='The client id to use.')
    secret: str | None = Field(None, description='The client secret to use, if any.')


class Oauth2Token(BaseModel):
    token: str = Field(..., description='The security token to use to use.')
    type: str = Field(..., description='The type of the security token to use to use.')


class Duration(BaseModel):
    days: int | None = Field(None, description='Number of days, if any.')
    hours: int | None = Field(None, description='Number of days, if any.')
    minutes: int | None = Field(None, description='Number of minutes, if any.')
    seconds: int | None = Field(None, description='Number of seconds, if any.')
    milliseconds: int | None = Field(
        None, description='Number of milliseconds, if any.'
    )


class Error(BaseModel):
    type: AnyUrl = Field(
        ..., description='A URI reference that identifies the error type.'
    )
    status: int = Field(
        ...,
        description='The status code generated by the origin for this occurrence of the error.',
    )
    instance: str = Field(
        ...,
        description='A JSON Pointer used to reference the component the error originates from.',
    )
    title: str | None = Field(
        None, description='A short, human-readable summary of the error.'
    )
    detail: str | None = Field(
        None,
        description='A human-readable explanation specific to this occurrence of the error.',
    )


class With(BaseModel):
    class Config:
        extra = Extra.allow

    id: str | None = Field(None, description="The event's unique identifier")
    source: str | None = Field(
        None, description='Identifies the context in which an event happened'
    )
    type: str | None = Field(
        None,
        description='This attribute contains a value describing the type of event related to the originating occurrence.',
    )
    time: str | None = None
    subject: str | None = None
    datacontenttype: str | None = Field(
        None,
        description='Content type of data value. This attribute enables data to carry any type of content, whereby format and encoding might differ from that of the chosen event format.',
    )
    dataschema: str | None = None


class Correlate(BaseModel):
    from_: str = Field(
        ...,
        alias='from',
        description='A runtime expression used to extract the correlation value from the filtered event.',
    )
    expect: str | None = Field(
        None,
        description="A constant or a runtime expression, if any, used to determine whether or not the extracted correlation value matches expectations. If not set, the first extracted value will be used as the correlation's expectation.",
    )


class EventFilter(BaseModel):
    with_: With = Field(
        ...,
        alias='with',
        description='An event filter is a mechanism used to selectively process or handle events based on predefined criteria, such as event type, source, or specific attributes.',
        title='WithEvent',
    )
    correlate: Dict[str, Correlate] | None = Field(
        None,
        description='A correlation is a link between events and data, established by mapping event attributes to specific data attributes, allowing for coordinated processing or handling based on event characteristics.',
    )


class Extend(Enum):
    call = 'call'
    composite = 'composite'
    emit = 'emit'
    for_ = 'for'
    listen = 'listen'
    raise_ = 'raise'
    run = 'run'
    set = 'set'
    switch = 'switch'
    try_ = 'try'
    wait = 'wait'
    all = 'all'


class Backoff(BaseModel):
    constant: Dict[str, Any] = Field(
        ..., description='The definition of the constant backoff to use, if any.'
    )


class Backoff1(BaseModel):
    exponential: Dict[str, Any] = Field(
        ..., description='The definition of the exponential backoff to use, if any.'
    )


class Backoff2(BaseModel):
    linear: Dict[str, Any] = Field(
        ..., description='The definition of the linear backoff to use, if any.'
    )


class Attempt(BaseModel):
    count: int | None = Field(
        None, description='The maximum amount of retry attempts, if any.'
    )
    duration: Duration | None = Field(
        None, description='The maximum duration for each retry attempt.'
    )


class Limit(BaseModel):
    attempt: Attempt | None = None
    duration: Duration | None = Field(
        None, description='The duration limit, if any, for all retry attempts.'
    )


class Jitter(BaseModel):
    from_: Duration = Field(
        ..., alias='from', description='The minimum duration of the jitter range'
    )
    to: Duration = Field(..., description='The maximum duration of the jitter range')


class RetryPolicy(BaseModel):
    when: str | None = Field(
        None,
        description='A runtime expression, if any, used to determine whether or not to retry running the task, in a given context.',
    )
    exceptWhen: str | None = Field(
        None,
        description='A runtime expression used to determine whether or not to retry running the task, in a given context.',
    )
    delay: Duration | None = Field(
        None, description='The duration to wait between retry attempts.'
    )
    backoff: Backoff | Backoff1 | Backoff2 | None = Field(
        None, description='The retry duration backoff.'
    )
    limit: Limit | None = Field(None, description='The retry limit, if any')
    jitter: Jitter | None = Field(
        None,
        description='The parameters, if any, that control the randomness or variability of the delay between retry attempts.',
    )


class Schema1(BaseModel):
    format: str | None = Field(
        'json',
        description="The schema's format. Defaults to 'json'. The (optional) version of the format can be set using `{format}:{version}`.",
    )
    document: Any = Field(..., description="The schema's inline definition.")


class Timeout(BaseModel):
    after: Duration = Field(..., description='The duration after which to timeout.')


class Raise(BaseModel):
    error: Error = Field(..., description='Defines the error to raise.')


class RaiseTask(BaseModel):
    raise_: Raise = Field(..., alias='raise')


class Switch(BaseModel):
    when: str | None = Field(
        None,
        description='A runtime expression used to determine whether or not the case matches.',
    )
    then: FlowDirective = Field(
        ..., description='The flow directive to execute when the case matches.'
    )


class SwitchTask(BaseModel):
    switch: List[Dict[str, Switch]] = Field(..., min_items=1)


class WaitTask(BaseModel):
    wait: Duration = Field(..., description='The amount of time to wait.')


class Oauth2(BaseModel):
    authority: AnyUrl = Field(
        ..., description='The URI that references the OAuth2 authority to use.'
    )
    grant: str = Field(..., description='The grant type to use.')
    client: Client
    scopes: List[str] | None = Field(
        None, description='The scopes, if any, to request the token for.'
    )
    audiences: List[str] | None = Field(
        None, description='The audiences, if any, to request the token for.'
    )
    username: str | None = Field(
        None,
        description='The username to use. Used only if the grant type is Password.',
    )
    password: str | None = Field(
        None,
        description='The password to use. Used only if the grant type is Password.',
    )
    subject: Oauth2Token | None = Field(
        None,
        description='The security token that represents the identity of the party on behalf of whom the request is being made.',
    )
    actor: Oauth2Token | None = Field(
        None,
        description='The security token that represents the identity of the acting party.',
    )


class AuthenticationPolicy3(BaseModel):
    oauth2: Oauth2 | SecretBasedAuthenticationPolicy


class AuthenticationPolicy(BaseModel):
    __root__: AuthenticationPolicy1 | AuthenticationPolicy2 | AuthenticationPolicy3 = (
        Field(..., description='Defines an authentication policy.')
    )


class EventConsumptionStrategy1(BaseModel):
    all: List[EventFilter] = Field(
        ..., description='A list containing all the events that must be consumed.'
    )


class EventConsumptionStrategy2(BaseModel):
    any: List[EventFilter] = Field(
        ..., description='A list containing any of the events to consume.'
    )


class EventConsumptionStrategy3(BaseModel):
    one: EventFilter = Field(..., description='The single event to consume.')


class EventConsumptionStrategy(BaseModel):
    __root__: (
        EventConsumptionStrategy1
        | EventConsumptionStrategy2
        | EventConsumptionStrategy3
    )


class Schedule(BaseModel):
    every: Duration | None = Field(
        None,
        description='Specifies the duration of the interval at which the workflow should be executed.',
    )
    cron: str | None = Field(
        None,
        description='Specifies the schedule using a cron expression, e.g., \'0 0 * * *\' for daily at midnight."',
    )
    after: Duration | None = Field(
        None,
        description='Specifies a delay duration that the workflow must wait before starting again after it completes.',
    )
    on: EventConsumptionStrategy | None = Field(
        None, description='Specifies the events that trigger the workflow execution.'
    )


class Listen(BaseModel):
    to: EventConsumptionStrategy = Field(
        ..., description='Defines the event(s) to listen to.'
    )


class ListenTask(BaseModel):
    listen: Listen


class ReferenceableAuthenticationPolicy(BaseModel):
    __root__: ReferenceableAuthenticationPolicy1 | AuthenticationPolicy


class Endpoint(BaseModel):
    uri: str = Field(..., description="The endpoint's URI.")
    authentication: ReferenceableAuthenticationPolicy | None = Field(
        None, description='The authentication policy to use.'
    )


class ExternalResource1(BaseModel):
    uri: AnyUrl = Field(..., description="The endpoint's URI.")
    authentication: ReferenceableAuthenticationPolicy | None = Field(
        None, description='The authentication policy to use.'
    )
    name: str | None = Field(None, description="The external resource's name, if any.")


class ExternalResource(BaseModel):
    __root__: AnyUrl | ExternalResource1


class Schema2(BaseModel):
    format: str | None = Field(
        'json',
        description="The schema's format. Defaults to 'json'. The (optional) version of the format can be set using `{format}:{version}`.",
    )
    resource: ExternalResource = Field(
        ..., description="The schema's external resource."
    )


class Schema(BaseModel):
    __root__: Schema1 | Schema2 = Field(
        ..., description='Represents the definition of a schema.'
    )


class Script1(BaseModel):
    language: str = Field(..., description='The language of the script to run.')
    environment: Dict[str, Any] | None = Field(
        None,
        description='A key/value mapping of the environment variables, if any, to use when running the configured process.',
        title='ScriptEnvironment',
    )
    source: ExternalResource


class Run1(BaseModel):
    script: Script | Script1


class RunTask(BaseModel):
    run: Run | Run1 | Run2 | Run3


class Input(BaseModel):
    schema_: Schema | None = Field(
        None,
        alias='schema',
        description='The schema used to describe and validate the input of the workflow or task.',
    )
    from_: str | Dict[str, Any] | None = Field(
        None,
        alias='from',
        description='A runtime expression, if any, used to mutate and/or filter the input of the workflow or task.',
    )


class Output(BaseModel):
    schema_: Schema | None = Field(
        None,
        alias='schema',
        description='The schema used to describe and validate the output of the workflow or task.',
    )
    as_: str | Dict[str, Any] | None = Field(
        None,
        alias='as',
        description='A runtime expression, if any, used to mutate and/or filter the output of the workflow or task.',
    )


class Export(BaseModel):
    schema_: Schema | None = Field(
        None,
        alias='schema',
        description='The schema used to describe and validate the workflow context.',
    )
    as_: str | Dict[str, Any] | None = Field(
        None,
        alias='as',
        description='A runtime expression, if any, used to export the output data to the context.',
    )


class TaskBase(BaseModel):
    if_: str | None = Field(
        None,
        alias='if',
        description='A runtime expression, if any, used to determine whether or not the task should be run.',
    )
    input: Input | None = Field(None, description="Configure the task's input.")
    output: Output | None = Field(None, description="Configure the task's output.")
    export: Export | None = Field(None, description='Export task output to context.')
    timeout: Timeout | None = Field(
        None, description="The task's timeout configuration, if any."
    )
    then: FlowDirective | None = Field(
        None,
        description='The flow directive to be performed upon completion of the task.',
    )


class CallTask(BaseModel):
    __root__: TaskBase


class Use(BaseModel):
    authentications: Dict[str, AuthenticationPolicy] | None = Field(
        None, description="The workflow's reusable authentication policies."
    )
    errors: Dict[str, Error] | None = Field(
        None, description="The workflow's reusable errors."
    )
    extensions: List[Dict[str, Extension]] | None = Field(
        None, description="The workflow's extensions."
    )
    functions: Dict[str, Task] | None = Field(
        None, description="The workflow's reusable functions."
    )
    retries: Dict[str, RetryPolicy] | None = Field(
        None, description="The workflow's reusable retry policies."
    )
    secrets: List[str] | None = Field(None, description="The workflow's secrets.")


class Model(BaseModel):
    document: Document = Field(..., description='Documents the workflow')
    input: Input | None = Field(None, description="Configures the workflow's input.")
    use: Use | None = Field(
        None, description="Defines the workflow's reusable components."
    )
    do: TaskList = Field(
        ..., description='Defines the task(s) the workflow must perform'
    )
    timeout: Timeout | None = Field(
        None, description="The workflow's timeout configuration, if any."
    )
    output: Output | None = Field(None, description="Configures the workflow's output.")
    schedule: Schedule | None = Field(None, description='Schedules the workflow')


class TaskList(BaseModel):
    __root__: List[Dict[str, Task]] = Field(..., title='TaskList')


class Task(BaseModel):
    __root__: (
        CallTask
        | DoTask
        | ForkTask
        | EmitTask
        | ForTask
        | ListenTask
        | RaiseTask
        | RunTask
        | SetTask
        | SwitchTask
        | TryTask
        | WaitTask
    )


class Fork(BaseModel):
    branches: TaskList
    compete: bool | None = Field(
        False,
        description="Indicates whether or not the concurrent tasks are racing against each other, with a single possible winner, which sets the composite task's output.",
    )


class ForkTask(BaseModel):
    fork: Fork


class DoTask(BaseModel):
    do: TaskList


class ForTask(BaseModel):
    for_: For = Field(..., alias='for')
    while_: str | None = Field(
        None,
        alias='while',
        description='A runtime expression that represents the condition, if any, that must be met for the iteration to continue.',
    )
    do: TaskList


class Catch(BaseModel):
    errors: Dict[str, Any] | None = Field(None, title='CatchErrors')
    as_: str | None = Field(
        None,
        alias='as',
        description="The name of the runtime expression variable to save the error as. Defaults to 'error'.",
    )
    when: str | None = Field(
        None,
        description='A runtime expression used to determine whether or not to catch the filtered error',
    )
    exceptWhen: str | None = Field(
        None,
        description='A runtime expression used to determine whether or not to catch the filtered error',
    )
    retry: RetryPolicy | None = Field(
        None, description='The retry policy to use, if any, when catching errors.'
    )
    do: TaskList | None = Field(
        None, description='The definition of the task(s) to run when catching an error.'
    )


class TryTask(BaseModel):
    try_: TaskList = Field(..., alias='try', description='The task(s) to perform.')
    catch: Catch


class Extension(BaseModel):
    extend: Extend = Field(..., description='The type of task to extend.')
    when: str | None = Field(
        None,
        description='A runtime expression, if any, used to determine whether or not the extension should apply in the specified context.',
    )
    before: TaskList | None = Field(
        None, description='The task(s) to execute before the extended task, if any.'
    )
    after: TaskList | None = Field(
        None, description='The task(s) to execute after the extended task, if any.'
    )


Use.update_forward_refs()
Model.update_forward_refs()
TaskList.update_forward_refs()
Task.update_forward_refs()
